{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to STORM Serve\n\n\nSTORM Serve is a web server written in Node that solves a lot of problems associated\nwith building javascript web applications.\n\n\nSTORM serve can do the following:\n\n\n\n\nServe sass that is auto-prefixed\n\n\nServe Javascript modules and track dependencies of a site per browser tab\n\n\nUglify resulting javascript for high performance websites\n\n\nProvide Aliases for code in module files, allowing for plugin based architecture in your application\n\n\nAllow for the creation of Isomorphic Websites via the use of an indexTransform\n\n\nAutomatically watch Javascript files and bust modules which have already been compiled.\n\n\nProvide simple glob matching to redirect requests to paths, or to custom handlers (see below)\n\n\nAllow you to create custom handlers that can be run on compiled Javascript and SASS code before it is served.\n\n\n\n\nWhoa thats a lot of stuff, break it down for me!\n\n\nIn a nuthshell, STORM Serve is like \nbrowserify on steroids as middleware for express\n with the ability to track which files you have already been served.\nTraditionaly, when using browserify, you generate static files, and your entire application is served in one go. But what happens\nwhen you need to build much larger sites, and you would prefer to live-load that code as the user starts browsing?\n\n\nWell thats where you would usually turn to libraries like browserify-factorify to sperate your code into chunks. This in itself is problematic\nand is not a good solution to the problem esepcially when you are building modular software and are not sure what plugins/modules are going to be loaded.\nTake this directory structure for example:\n\n\nsite core\n    page1.js (react)\n    page2.js (react,D3)\n    page3.js (react,D3)\n    page4.js (react)\n\nplugins\n    plugin1\n        page5.js (react)\n        page6.js (react,D3,angular)\n    plugin2\n        page7.js (react)\n        page8.js (react,D3)\n\n\n\n\nIn the above example, we have the core site, which has its pages that all use react, but we also have some plugins that use react.\nOntop of that, page 6 in plugin 1 uses angular, and that page might only be loaded if you are an admin.\n\n\nTherefore we can make some assumptions:\n\n\n\n\nIt is not a good idea to browserify the entire site into one big bundle, because we send unnesesary amounts of possibly large code\n\n\nWe still want to be able to write in modules, and use require(\"react\") in every page\n\n\nWe dont want to send over react every single time the user loads a different page (ReactClass)", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-storm-serve", 
            "text": "STORM Serve is a web server written in Node that solves a lot of problems associated\nwith building javascript web applications.", 
            "title": "Welcome to STORM Serve"
        }, 
        {
            "location": "/#storm-serve-can-do-the-following", 
            "text": "Serve sass that is auto-prefixed  Serve Javascript modules and track dependencies of a site per browser tab  Uglify resulting javascript for high performance websites  Provide Aliases for code in module files, allowing for plugin based architecture in your application  Allow for the creation of Isomorphic Websites via the use of an indexTransform  Automatically watch Javascript files and bust modules which have already been compiled.  Provide simple glob matching to redirect requests to paths, or to custom handlers (see below)  Allow you to create custom handlers that can be run on compiled Javascript and SASS code before it is served.", 
            "title": "STORM serve can do the following:"
        }, 
        {
            "location": "/#whoa-thats-a-lot-of-stuff-break-it-down-for-me", 
            "text": "In a nuthshell, STORM Serve is like  browserify on steroids as middleware for express  with the ability to track which files you have already been served.\nTraditionaly, when using browserify, you generate static files, and your entire application is served in one go. But what happens\nwhen you need to build much larger sites, and you would prefer to live-load that code as the user starts browsing?  Well thats where you would usually turn to libraries like browserify-factorify to sperate your code into chunks. This in itself is problematic\nand is not a good solution to the problem esepcially when you are building modular software and are not sure what plugins/modules are going to be loaded.\nTake this directory structure for example:  site core\n    page1.js (react)\n    page2.js (react,D3)\n    page3.js (react,D3)\n    page4.js (react)\n\nplugins\n    plugin1\n        page5.js (react)\n        page6.js (react,D3,angular)\n    plugin2\n        page7.js (react)\n        page8.js (react,D3)  In the above example, we have the core site, which has its pages that all use react, but we also have some plugins that use react.\nOntop of that, page 6 in plugin 1 uses angular, and that page might only be loaded if you are an admin.  Therefore we can make some assumptions:   It is not a good idea to browserify the entire site into one big bundle, because we send unnesesary amounts of possibly large code  We still want to be able to write in modules, and use require(\"react\") in every page  We dont want to send over react every single time the user loads a different page (ReactClass)", 
            "title": "Whoa thats a lot of stuff, break it down for me!"
        }, 
        {
            "location": "/guide/", 
            "text": "Getting Started\n\n\nThe simplest way to get started with storm serve, is with the following directory structure:\n\n\nDirectory structure\n\n\nserver.js\nindex.html\npackage.json\n\nnode_modules\n    \nmoduleshere\n\nmedia\n    logo.png\nsass\n    style.scss\nmodules\n    main.js\n\n\n\n\nindex.html\n\n\n!DOCTYPE html\n\n\nhtml\n\n    \nhead\n\n        \ntitle\nMy First Storm Website\n/title\n\n        \nmeta charset=\nutf-8\n\n        \nscript src=\nmain.js\n/script\n\n        \nlink rel=\nstylesheet\n href=\nmain.scss\n/\n\n    \n/head\n\n    \nbody\n\n        \nimg src=\nlogo.png\n\n    \n/body\n\n\n/html\n\n\n\n\n\nserver.js\n\n\nvar StormServe  = require(\nstorm-serve\n);\nvar express     = require('express');\n\nvar app = express();\n\n//serve javascript and index.html\napp.use(StormServe.main({\n\n    mappings:{\n        \n/index.html\n:  __dirname + \n/index.html\n,\n        \n/*.js\n:        __dirname + \n/javascript\n,\n        \n/*.scss\n:      __dirname + \n/sass\n,\n    },\n}));\n//serve css (that is converted from sass)\napp.use(StormServe.scss());\n\n//serve static files like images\napp.use(express.static(path.resolve(__dirname+\n/media\n)));\n\n//start the server on port 80\napp.listen(8080);\n\n\n\n\nmain.js\n\n\nvar react = require(\nreact\n)\nwindow.onload = function(){\n    React.render(React.DOM.h1(null,'Hello World!'),document.body)\n}\n\n\n\n\nstyle.scss\n\n\n*{\n    margin: 0;\n    padding: 0;\n}\n\nbody{\n    display: flex; //this is run through auto prefixer\n}\n\n\n\n\nNext Steps\n\n\nrun this on your machine\n\n\nnode server.js //this starts the web server\n\n\nand then open up your browser to \n\n\nhttp://localhost:8080\n\n\nNow wait while storm serve, compiles your website, and then eventually loads. After that perform a refresh and the site should load blazingly fast.\n\n\nSo what happened\n\n\nIn this order, your browser will:\n\n\n\n\n\n\nServe the index file which will:\n\n\n\n\nBe injected with a window-variable used to identify this instance of the browser tab\n\n\nInject a script which allows you to call window.loadModule\n\n\nRewrite the links of all your script assets to include the window-variable\n\n\n\n\n\n\n\n\nRequest main.scss and this will be redirected internally to /sass/main.scss which will then:\n\n\n\n\nBe converted to sass\n\n\nRun through auto prefixer\n\n\n\n\n\n\n\n\nRequest main.js and this will be redirected internally to /javascript/main.js which will then:\n\n\n\n\nbe run through a supercharged browserify pipeline\n\n\napply any source transformations\n\n\nmap the filenames to a hashed version of each files contents\n\n\nrewrite the requires(), so that they point to the hashed filenames\n\n\nserve the ES5 script to the browser", 
            "title": "User Guide"
        }, 
        {
            "location": "/guide/#getting-started", 
            "text": "The simplest way to get started with storm serve, is with the following directory structure:", 
            "title": "Getting Started"
        }, 
        {
            "location": "/guide/#directory-structure", 
            "text": "server.js\nindex.html\npackage.json\n\nnode_modules\n     moduleshere \nmedia\n    logo.png\nsass\n    style.scss\nmodules\n    main.js  index.html  !DOCTYPE html  html \n     head \n         title My First Storm Website /title \n         meta charset= utf-8 \n         script src= main.js /script \n         link rel= stylesheet  href= main.scss / \n     /head \n     body \n         img src= logo.png \n     /body  /html   server.js  var StormServe  = require( storm-serve );\nvar express     = require('express');\n\nvar app = express();\n\n//serve javascript and index.html\napp.use(StormServe.main({\n\n    mappings:{\n         /index.html :  __dirname +  /index.html ,\n         /*.js :        __dirname +  /javascript ,\n         /*.scss :      __dirname +  /sass ,\n    },\n}));\n//serve css (that is converted from sass)\napp.use(StormServe.scss());\n\n//serve static files like images\napp.use(express.static(path.resolve(__dirname+ /media )));\n\n//start the server on port 80\napp.listen(8080);  main.js  var react = require( react )\nwindow.onload = function(){\n    React.render(React.DOM.h1(null,'Hello World!'),document.body)\n}  style.scss  *{\n    margin: 0;\n    padding: 0;\n}\n\nbody{\n    display: flex; //this is run through auto prefixer\n}", 
            "title": "Directory structure"
        }, 
        {
            "location": "/guide/#next-steps", 
            "text": "run this on your machine  node server.js //this starts the web server  and then open up your browser to   http://localhost:8080  Now wait while storm serve, compiles your website, and then eventually loads. After that perform a refresh and the site should load blazingly fast.  So what happened  In this order, your browser will:    Serve the index file which will:   Be injected with a window-variable used to identify this instance of the browser tab  Inject a script which allows you to call window.loadModule  Rewrite the links of all your script assets to include the window-variable     Request main.scss and this will be redirected internally to /sass/main.scss which will then:   Be converted to sass  Run through auto prefixer     Request main.js and this will be redirected internally to /javascript/main.js which will then:   be run through a supercharged browserify pipeline  apply any source transformations  map the filenames to a hashed version of each files contents  rewrite the requires(), so that they point to the hashed filenames  serve the ES5 script to the browser", 
            "title": "Next Steps"
        }, 
        {
            "location": "/advanced/", 
            "text": "Handlers\n\n\nIn some cases, we need more than a file glob match to perform a function. For this purpose,\nSTORM Serve allows you to register handlers (for example):\n\n\nhandlers:[\n    function (queryParams) {\n        if (queryParams.pathname === 'somefile.js' \n queryParams.query.ID) {\n            return __dirname+\n/somefile.js\n;\n        }\n    }\n]\n\n\n\n\nWhen working with handlers, you can return a file that will be served, or you can return an object containing\n\nsrc\n and \nextname\n fields. Returning an object will allow you to return actual source code and specify what type of code it is.\nThis means you can return sass or javascript code directly, and it will be browserified or converted to sass.\n\n\nWhy is this useful?\n\n\nIn some rare cases, you might find yourself having to return sass code that might be contained in a namespace (for example:)\n\n\nhandlers:[\n    function (queryParams) {\n        if (path.extname(queryParams.pathname) === '.scss' \n queryParams.query.ID) {\n            var code = fs.readFileSync(decodeURI(queryParams.pathname));\n\n            //wrap the code in a class (browser requested namespaced css)\n            return {\n                src: '.' + queryParams.query.FACTORY_ID + '{' + code + \n}\n,\n                extname: '.scss'\n            };\n        }\n    }\n]\n\n\n\n\nWhatever the reason, if a mapping is not good-enough, use a handler and do the checks on the queryParams yourself.\n\n\nMappings\n\n\nMappings are like a simple way to use handlers (see above), there are a number of ways to use mappings:\n\n\nmappings : {\n    //point a mapping to an absolute file\n    \n/index.html\n : __dirname + \n/../tests/index.html\n,\n\n    //only allow a or d, (and then append the incoming request)\n    \n/+(a|d).js\n : __dirname + \n/../tests/js\n,\n\n    //all sass files get send to the sass dir\n    \n/*.scss\n : __dirname + \n/../tests/sass\n,\n\n    //use a handler for this file glob (works like the above handlers)\n    \n/test1.js\n   : function(url){\n        return {src: \nconsole.log('test1 worked');\n, extname:'.js'};\n    }\n},\n\n\n\n\nIndex Transform / Isomorphic Websites\n\n\nWhen building isomorphic applications, you will want to do server side rendering. \nIn this case, provide an index transform, which is run just before STORM servers the \nindex\n file.\n\n\n!DOCTYPE html\n\n\nhtml\n\n    \nhead\n\n        \ntitle\nMy First Storm Website\n/title\n\n        \nmeta charset=\nutf-8\n\n        \nscript src=\nmain.js\n/script\n\n        \nlink rel=\nstylesheet\n href=\nmain.scss\n/\n\n    \n/head\n\n    \nbody\n\n        \n%= react %\n\n    \n/body\n\n\n/html\n\n\n\n\n\nindexTransform: function(request,content){\n\n    //required for react to work\n    process.env.NODE_ENV = 'development';\n\n    var data = {\n        react: React.renderToString(React.DOM.h1(null,\nHello World\n))\n    };\n\n    return (_.template(content))(data);\n},\n\n\n\n\nControl the dependency tree\n\n\nIf you want to have tighter control over our custom browserify pipeline,\nyou can pass in options to the exposed services using the \ndeps\n key.\n\n\nnpm libraries that are exposed are:\n\n\n\n\nuglify\n : Uglify JS\n\n\nmoduleDeps\n : Module Deps (Browserify)\n\n\nchokidar\n : Chokidar (we use this for watching files to bust cache)\n\n\n\n\ndeps : {\n    //turn on/off uglify or pass in options\n    uglify: false || { \noptionsForUglifyJS\n },\n\n    //pass additional options to Module Deps (the browserify pipeline)\n    moduleDeps:{\n        noParse : ['react'],\n    }\n}\n\n\n\n\nAliases\n\n\nIf you want to force STORM Serve to use a particular file when doing a require(), you can override this here.\n\n\naliases: {\n    \nreact/addons\n : __dirname + \n/../node_modules/react/dist/react-with-addons.js\n,\n    \nreact\n :        __dirname + \n/../node_modules/react/dist/react-with-addons.js\n,\n\n    //this is useful if you want to simply call require(\nMyApplication\n); anywhere within your app\n    \nMyApplication\n: __dirname + \n/some/dir/app.js\n\n},\n\n\n\n\nAliases are useful for building sites that use plugins, or where there are many files, and you want to avoid require(\"../../../../\")\nAliases are also useful if you want to prevent the Dependency engine from crawling a massive library like React. In this case,\nits much more efficient to point \"react\" to the minified library.\n\n\nDocker / Remote Filesystems\n\n\nStorm serve watches every javascript file that in the debs tree, and when the file changes, it busts the cache.\nThe problem is, on some remote file systems, this does not happen fast enough, because the filesystem does not trigger\nthe fs event required to bust the cache, While this is not a problem in production, this can make it complicated\nto work with docker.\n\n\nFor this purposes, there is a standlone node script you can run on your host machine. The idea is to watch for changes on your host\nmachine and then remotely tell STORM Serve that the file has changed (Here we assume you are mounting the files into your remote file system using\nsomething like NFS).\n\n\nDocker and docker-compose\n\n\nSimply run:\n\n\n\nnode container-node/node_modules/storm-serve/src/HostWatcher.js \\\n    --host http://docker.local:8092 \\\n    --dockerComposeFile docker-compose.yml \n    --dockerComposeKey node\n\n\n\n\nWhere \nhost\n is the address and port of the middleware,\n\ndockerComposeFile\n is the name of your compose file and\n\ndockerComposeKey\n is the name of your container that is running storm-serve", 
            "title": "Advanced Guide"
        }, 
        {
            "location": "/advanced/#handlers", 
            "text": "In some cases, we need more than a file glob match to perform a function. For this purpose,\nSTORM Serve allows you to register handlers (for example):  handlers:[\n    function (queryParams) {\n        if (queryParams.pathname === 'somefile.js'   queryParams.query.ID) {\n            return __dirname+ /somefile.js ;\n        }\n    }\n]  When working with handlers, you can return a file that will be served, or you can return an object containing src  and  extname  fields. Returning an object will allow you to return actual source code and specify what type of code it is.\nThis means you can return sass or javascript code directly, and it will be browserified or converted to sass.", 
            "title": "Handlers"
        }, 
        {
            "location": "/advanced/#why-is-this-useful", 
            "text": "In some rare cases, you might find yourself having to return sass code that might be contained in a namespace (for example:)  handlers:[\n    function (queryParams) {\n        if (path.extname(queryParams.pathname) === '.scss'   queryParams.query.ID) {\n            var code = fs.readFileSync(decodeURI(queryParams.pathname));\n\n            //wrap the code in a class (browser requested namespaced css)\n            return {\n                src: '.' + queryParams.query.FACTORY_ID + '{' + code +  } ,\n                extname: '.scss'\n            };\n        }\n    }\n]  Whatever the reason, if a mapping is not good-enough, use a handler and do the checks on the queryParams yourself.", 
            "title": "Why is this useful?"
        }, 
        {
            "location": "/advanced/#mappings", 
            "text": "Mappings are like a simple way to use handlers (see above), there are a number of ways to use mappings:  mappings : {\n    //point a mapping to an absolute file\n     /index.html  : __dirname +  /../tests/index.html ,\n\n    //only allow a or d, (and then append the incoming request)\n     /+(a|d).js  : __dirname +  /../tests/js ,\n\n    //all sass files get send to the sass dir\n     /*.scss  : __dirname +  /../tests/sass ,\n\n    //use a handler for this file glob (works like the above handlers)\n     /test1.js    : function(url){\n        return {src:  console.log('test1 worked'); , extname:'.js'};\n    }\n},", 
            "title": "Mappings"
        }, 
        {
            "location": "/advanced/#index-transform-isomorphic-websites", 
            "text": "When building isomorphic applications, you will want to do server side rendering. \nIn this case, provide an index transform, which is run just before STORM servers the  index  file.  !DOCTYPE html  html \n     head \n         title My First Storm Website /title \n         meta charset= utf-8 \n         script src= main.js /script \n         link rel= stylesheet  href= main.scss / \n     /head \n     body \n         %= react % \n     /body  /html   indexTransform: function(request,content){\n\n    //required for react to work\n    process.env.NODE_ENV = 'development';\n\n    var data = {\n        react: React.renderToString(React.DOM.h1(null, Hello World ))\n    };\n\n    return (_.template(content))(data);\n},", 
            "title": "Index Transform / Isomorphic Websites"
        }, 
        {
            "location": "/advanced/#control-the-dependency-tree", 
            "text": "If you want to have tighter control over our custom browserify pipeline,\nyou can pass in options to the exposed services using the  deps  key.  npm libraries that are exposed are:   uglify  : Uglify JS  moduleDeps  : Module Deps (Browserify)  chokidar  : Chokidar (we use this for watching files to bust cache)   deps : {\n    //turn on/off uglify or pass in options\n    uglify: false || {  optionsForUglifyJS  },\n\n    //pass additional options to Module Deps (the browserify pipeline)\n    moduleDeps:{\n        noParse : ['react'],\n    }\n}", 
            "title": "Control the dependency tree"
        }, 
        {
            "location": "/advanced/#aliases", 
            "text": "If you want to force STORM Serve to use a particular file when doing a require(), you can override this here.  aliases: {\n     react/addons  : __dirname +  /../node_modules/react/dist/react-with-addons.js ,\n     react  :        __dirname +  /../node_modules/react/dist/react-with-addons.js ,\n\n    //this is useful if you want to simply call require( MyApplication ); anywhere within your app\n     MyApplication : __dirname +  /some/dir/app.js \n},  Aliases are useful for building sites that use plugins, or where there are many files, and you want to avoid require(\"../../../../\")\nAliases are also useful if you want to prevent the Dependency engine from crawling a massive library like React. In this case,\nits much more efficient to point \"react\" to the minified library.", 
            "title": "Aliases"
        }, 
        {
            "location": "/advanced/#docker-remote-filesystems", 
            "text": "Storm serve watches every javascript file that in the debs tree, and when the file changes, it busts the cache.\nThe problem is, on some remote file systems, this does not happen fast enough, because the filesystem does not trigger\nthe fs event required to bust the cache, While this is not a problem in production, this can make it complicated\nto work with docker.  For this purposes, there is a standlone node script you can run on your host machine. The idea is to watch for changes on your host\nmachine and then remotely tell STORM Serve that the file has changed (Here we assume you are mounting the files into your remote file system using\nsomething like NFS).", 
            "title": "Docker / Remote Filesystems"
        }, 
        {
            "location": "/advanced/#docker-and-docker-compose", 
            "text": "Simply run:  \nnode container-node/node_modules/storm-serve/src/HostWatcher.js \\\n    --host http://docker.local:8092 \\\n    --dockerComposeFile docker-compose.yml \n    --dockerComposeKey node  Where  host  is the address and port of the middleware, dockerComposeFile  is the name of your compose file and dockerComposeKey  is the name of your container that is running storm-serve", 
            "title": "Docker and docker-compose"
        }
    ]
}